// Fichier de schéma Prisma
// Chaque "model" correspond à une table dans PostgreSQL

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// Table des utilisateurs
model User {
  id        Int          @id @default(autoincrement()) // Clé primaire auto-incrémentée
  email     String       @unique @db.VarChar(255)      // Email unique (pas de doublons)
  password  String       @db.VarChar(255)              // Hash bcrypt (~60 chars, 255 par sécurité)
  name      String       @db.VarChar(100)              // Nom affiché
  createdAt DateTime     @default(now())               // Date de création automatique
  updatedAt DateTime     @updatedAt                    // Mis à jour automatiquement à chaque modification
  isEmailChecked Boolean @default(false)               // True après vérification de l'email (link on mail)

  // Relation : un User peut avoir plusieurs Posts
  posts Post[]
  // Relation : un User peut avoir plusieurs Rôles
  roles UserRole[]
  // Relation : un User peut avoir plusieurs Refresh Tokens (multi-appareils)
  refreshTokens RefreshToken[]
  emailVerifications EmailVerification[]

  // Nom de la table en base de données (convention snake_case en SQL)
  @@map("users")
}

// Table des refresh tokens (un par session/appareil)
model RefreshToken {
  id        Int      @id @default(autoincrement())
  token     String   @db.VarChar(500)
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("refresh_tokens")
}

// Table des tokens de vérification d'email
model EmailVerification {
  id        Int      @id @default(autoincrement())
  token     String   @db.VarChar(500)
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("email_verifications")
}

// Table des posts
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)               // Titre du post
  content   String   @db.Text                      // Contenu du post (texte long, pas de limite)
  published Boolean  @default(false)               // Brouillon par défaut
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relation : chaque Post appartient à un User
  author   User @relation(fields: [authorId], references: [id])
  authorId Int  // Clé étrangère vers User

  @@map("posts")
}

// Table des rôles (USER, ADMIN, MODERATOR...)
model Role {
  id          Int              @id @default(autoincrement())
  name        String           @unique @db.VarChar(50)
  users       UserRole[]
  permissions RolePermission[]
  @@map("roles")
}

// Table des permissions (READ_USER, EDIT_OWN_PROFILE...)
model Permission {
  id    Int              @id @default(autoincrement())
  name  String           @unique @db.VarChar(100)
  roles RolePermission[]
  @@map("permissions")
}

// Table pivot : quelles permissions a chaque rôle (many-to-many)
model RolePermission {
  roleId       Int
  permissionId Int
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  @@id([roleId, permissionId])
  @@map("role_permissions")
}

// Table pivot : quels rôles a chaque utilisateur (many-to-many)
model UserRole {
  userId Int
  roleId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role   Role @relation(fields: [roleId], references: [id], onDelete: Cascade)
  @@id([userId, roleId])
  @@map("user_roles")
}
