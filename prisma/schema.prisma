// Fichier de schéma Prisma
// Chaque "model" correspond à une table dans PostgreSQL

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// Table des utilisateurs
model User {
  id        Int          @id @default(autoincrement()) // Clé primaire auto-incrémentée
  email     String       @unique @db.VarChar(255)      // Email unique (pas de doublons)
  password  String       @db.VarChar(255)              // Hash bcrypt (~60 chars, 255 par sécurité)
  name      String       @db.VarChar(100)              // Nom affiché
  createdAt DateTime     @default(now())               // Date de création automatique
  updatedAt DateTime     @updatedAt                    // Mis à jour automatiquement à chaque modification
  isEmailChecked      Boolean   @default(false)               // True après vérification de l'email (link on mail)
  failedLoginAttempts Int       @default(0)                   // Compteur de tentatives de connexion échouées
  lockedUntil         DateTime?                               // Verrouillé jusqu'à cette date (null = non verrouillé)

  // Relation : un User peut avoir plusieurs Rôles
  roles UserRole[]
  // Relation : un User peut avoir plusieurs Refresh Tokens (multi-appareils)
  refreshTokens RefreshToken[]
  emailVerifications EmailVerification[]
  passwordResets PasswordReset[]

  // Nom de la table en base de données (convention snake_case en SQL)
  @@map("users")
}

// Table des refresh tokens (un par session/appareil)
model RefreshToken {
  id        Int      @id @default(autoincrement())
  token     String   @db.VarChar(500)
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("refresh_tokens")
}

// Table des tokens de vérification d'email
model EmailVerification {
  id        Int      @id @default(autoincrement())
  token     String   @db.VarChar(500)
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("email_verifications")
}

// Table des tokens de réinitialisation de mot de passe
model PasswordReset {
  id        Int      @id @default(autoincrement())
  token     String   @db.VarChar(500)
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("password_resets")
}

// Table des rôles (USER, ADMIN, MODERATOR...)
model Role {
  id          Int              @id @default(autoincrement())
  name        String           @unique @db.VarChar(50)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  users       UserRole[]
  permissions RolePermission[]
  @@map("roles")
}

// Table des permissions (READ_USER, EDIT_OWN_PROFILE...)
model Permission {
  id    Int              @id @default(autoincrement())
  name  String           @unique @db.VarChar(100)
  roles RolePermission[]
  @@map("permissions")
}

// Table pivot : quelles permissions a chaque rôle (many-to-many)
model RolePermission {
  roleId       Int
  permissionId Int
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  @@id([roleId, permissionId])
  @@map("role_permissions")
}

// Table pivot : quels rôles a chaque utilisateur (many-to-many)
model UserRole {
  userId Int
  roleId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role   Role @relation(fields: [roleId], references: [id], onDelete: Cascade)
  @@id([userId, roleId])
  @@map("user_roles")
}

// Table des logs d'audit (actions importantes tracées)
model AuditLog {
  id         Int      @id @default(autoincrement())
  action     String   @db.VarChar(100)
  actorId    Int?
  targetId   Int?
  targetType String?  @db.VarChar(50)
  metadata   Json?
  createdAt  DateTime @default(now())

  @@map("audit_logs")
}
